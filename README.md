# Discovery

_Discovery_ is a next-generation pulsar-timing-array data-analysis package, _built for speed_ on a [JAX](https://jax.readthedocs.io/en/latest/) backend that supports GPU execution and autodifferentiation.
If [Enterprise](https://github.com/nanograv/enterprise) is Spock, logical and elegant, _Discovery_ is all Scotty, fast, efficient, and not above a hack if it gets you to warp speed.

# Data model

The data model consists of `Kernel` objects (think of a noise matrix `N`, which can be inverted and applied to a vector, `N^{-1} y`, or even sandwiched with it, `y^T N^{-1} y`) and of `GP` objects, consisting of a basis `F` (sized `ntoas x ngp`) and a prior/kernel `Phi`. The kernel `ShermanMorrisonKernel(N, F, P)` combines a noise kernel and a GP.

## Pulsar data

_Discovery_ currently uses _Enterprise_ `Pulsar` objects.

## Noise and signal components (`signals.py`)

- `residuals(psr)`: just a `numpy` array of residuals for pulsar `psr`.

- `makenoise_measurement(psr, [noisedict])`: returns a `Kernel` object that implements EFAC + EQUAD measurement noise for pulsar `psr`. Parameters are multiplexed to pulsar and backend (e.g., `B1855+09_430_ASP_efac`), _Enterprise_-style. If those parameters appear is `noisedict`, their values will be frozen to those specifications.
- `makenoise_measurement_simple(psr, [noisedict])`: same, but no backends.
- `makegp_ecorr(psr, [noisedict])`: returns a `GP` object that implements ECORR measurement noise for pulsar `psr`. The quantization style. Parameters are multiplexed to pulsar and backend, and frozen if included in noisedict.
- `makegp_ecorr_simple(psr, [noisedict])`: same, but no backends.

- `makegp_fourier(psr, prior, components, [T, fourierbasis, common, name])`: returns a `GP` object that implements a finite GP over a vector basis. Here `prior` must be a JAX-ready function with signature `priorfunc(f, df, arg1, arg2)`, where `f` is a vector of frequencies, and `df` a vector of integration weights associated with the frequencies. The resulting GP parameters are named `{psrname}_{name}_{arg1}`, etc., unless they are named in `common`. The Fourier basis is generated by calling `fourierbasis(psr, components, T)`, which must return `(f, df, F)`. In this function `T` defaults to the pulsar span.
- `makegp_improper(psr, fmat, [constant, name])`: returns a `GP` object with improper prior (formally, a constant vector equal to `constant`) and basis matrix `fmat`. Here `constant` defaults to `1e40`.
- `makegp_timing(psr, [constant])`: convenience function to call `makegp_improper` with the pulsar design matrix `psr.Mmat`. The columns are normalized.

## GP basis and priors (`signals.py`)

- `fourierbasis(psr, components, [T])`: returns `(f, df, F)` for a basis of interleaved sines and cosines evaluated over `psr` TOAs with frequencies `k/T`, with `k = 1, ..., components`. Again `T` defaults to the pulsar span.
- `dmfourierbasis(psr, components, [T, fref])`: same, but rescales the basis by `(fref / psr.freqs)**2`, useful to define DMGP. Here `T` defaults to the pulsar span and `fref` to 1400.

- `powerlaw(f, df, log10_A, gamma)`: implements the standard red-noise/GW spectrum `10^(2 log10_A) f^(-gamma) (yr^(gamma - 3) / pi^2 / 12) df`. This is a JAX-able function, so one would pass `powerlaw` to `makegp_fourier`.
- `freespectrum(f, df, log10_rho: typing.Sequence)`: implements `10^(2 log10_rho)`. Note that `makegp_fourier` uses the `log10_rho` annotation to treat it as a vector; the resulting parameter name would be, e.g., `B1855+09_fourierGP_log10_rho(10)` if `components = 10`.
- `makepowerlaw_crn(components)`: makes the prior for a combined red-noise/common-process GP, limiting the common-process to `components` frequencies. Returns a function with the signature `powerlaw_crn(f, df, log10_A, gamma, crn_log10_A, crn_gamma)`; calling `makegp_fourier(..., common=['crn_log10_A, crn_gamma'], name='rednoise')` would then result in parameter names `['B1855+09_rednoise_log10_A', 'B1855+09_rednoise_gamma', ..., 'crn_log10_A', 'crn_gamma']`.

## Likelihood (`likelihood.py`)

