# Discovery

_Discovery_ is a next-generation pulsar-timing-array data-analysis package, _built for speed_ on a [JAX](https://jax.readthedocs.io/en/latest/) backend that supports GPU execution and autodifferentiation.
If [Enterprise](https://github.com/nanograv/enterprise) is Spock, logical and elegant, _Discovery_ is all Scotty, fast, efficient, and not above a hack if it gets you to warp speed.

# Data model

The data model consists of `Kernel` objects (think of a noise matrix `N`, which can be inverted and applied to a vector, `N^{-1} y`, or even sandwiched with it, `y^T N^{-1} y`) and of `GP` objects, consisting of a basis `F` (sized `ntoas x ngp`) and a prior/kernel `Phi`. The kernel `ShermanMorrisonKernel(N, F, P)` combines a noise kernel and a GP.

## Pulsar data

_Discovery_ currently uses _Enterprise_ `Pulsar` objects.

## Noise and signal components (`signals.py`)

- `residuals(psr)`: just a `numpy` array of residuals for pulsar `psr`.

- `makenoise_measurement(psr, [noisedict])`: returns a `Kernel` object that implements EFAC + EQUAD measurement noise for pulsar `psr`. Parameters are multiplexed to pulsar and backend (e.g., `B1855+09_430_ASP_efac`), _Enterprise_-style. If those parameters appear is `noisedict`, their values will be frozen to those specifications.
- `makenoise_measurement_simple(psr, [noisedict])`: same, but no backends.
- `makegp_ecorr(psr, [noisedict])`: returns a `GP` object that implements ECORR measurement noise for pulsar `psr`. The quantization style. Parameters are multiplexed to pulsar and backend, and frozen if included in noisedict.
- `makegp_ecorr_simple(psr, [noisedict])`: same, but no backends.

- `makegp_fourier(psr, prior, components, [T, fourierbasis, common, name])`: returns a `GP` object that implements a finite GP over a vector basis. Here `prior` must be a JAX-ready function with signature `priorfunc(f, df, arg1, arg2)`, where `f` is a vector of frequencies, and `df` a vector of integration weights associated with the frequencies. The resulting GP parameters are named `{psrname}_{name}_{arg1}`, etc., unless they are included in the list `common`. The Fourier basis is generated by calling `fourierbasis(psr, components, T)` (see below), which must return `(f, df, F)`. In this function `T` defaults to the pulsar span.
- `makegp_improper(psr, fmat, [constant, name])`: returns a `GP` object with improper prior (formally, a constant vector equal to `constant`) and basis matrix `fmat`. Here `constant` defaults to `1e40`.
- `makegp_timing(psr, [constant])`: convenience function to call `makegp_improper` with the pulsar design matrix `psr.Mmat`. The columns are normalized.

## GP basis and priors (`signals.py`)

- `fourierbasis(psr, components, [T])`: returns `(f, df, F)` for a basis of interleaved sines and cosines evaluated over `psr` TOAs with frequencies `k/T`, with `k = 1, ..., components`. Again `T` defaults to the pulsar span.
- `dmfourierbasis(psr, components, [T, fref])`: same, but rescales the basis by `(fref / psr.freqs)**2`, useful to define DMGP. Here `T` defaults to the pulsar span and `fref` to 1400.

- `powerlaw(f, df, log10_A, gamma)`: implements the standard red-noise/GW spectrum `10^(2 log10_A) f^(-gamma) (yr^(gamma - 3) / pi^2 / 12) df`. This is a JAX-able function, so one would pass `powerlaw` to `makegp_fourier`.
- `freespectrum(f, df, log10_rho: typing.Sequence)`: implements `10^(2 log10_rho)`. Note that `makegp_fourier` uses the `log10_rho` annotation to treat it as a vector; the resulting parameter name would be, e.g., `B1855+09_fourierGP_log10_rho(10)` if `components = 10`.
- `makepowerlaw_crn(components)`: makes the prior for a combined red-noise/common-process GP, limiting the common-process to `components` frequencies. Returns a function with the signature `powerlaw_crn(f, df, log10_A, gamma, crn_log10_A, crn_gamma)`; calling `makegp_fourier(..., common=['crn_log10_A, crn_gamma'], name='rednoise')` would then result in parameter names `['B1855+09_rednoise_log10_A', 'B1855+09_rednoise_gamma', ..., 'crn_log10_A', 'crn_gamma']`.

## Likelihood (`likelihood.py`)

- `PulsarLikelihood(signals, concat=True)`: returns a `PulsarLikelihood` object, with a `logL` property that implements the single-pulsar likelihood as a JAX-able function. The likelihood takes as a single argument a dictionary of parameters named as discussed above. Here `signals` is an iterable that must contain exactly one residual vector, exactly one noise `Kernel`, and any number of `GP` objects. If `concat=False`, the likelihood is built by nesting `ShermanMorrisonKernel`s, first consuming `ConstantGP` objects (those without parameters) and then `VariableGP`, but otherwise respecting the order in `signals`. If `concat=True`, the `ConstantGP`s and `VariableGP`s are separately concatenated, and then nested.

## Priors (`prior.py`)

- `makelogprior_uniform(params, [priordict])`: returns a function `logprior(params)` that evaluates the total log prior according to `priordict` (given, e.g., as `{'FourierGP_log10_A': [-18, -11]'}`). Some standard [`enterprise_extensions`](https://github.com/nanograv/enterprise_extensions) priors are included by default (e.g., `crn_log10_A, crn_gamma, gw_log10_A, gw_gamma, ...`). Parameters that are in the list `params` but are not in `priordict` and have no default are not included in the computation.
- `sample_uniform(params, [priordict])`: creates a dictionary of random values for the parameters in the list `params`, using the uniform priors in `priordict` or in the system default. Fails if a parameter in `params` has no specification.

# Example usage

The following implements a standard NANOGrav likelihood + prior for pulsar `psr`, with free parameters `['{psrname}_rednoise_gamma', '{psrname}_rednoise_log10_A', 'crn_gamma', 'crn_log10_A']`:

```
import discovery as ds

psl = ds.PulsarLikelihood([psr.residuals,
                           ds.makenoise_measurement(psr, noisedict),
                           ds.makegp_ecorr(psr, noisedict),
                           ds.makegp_timing(psr),
                           ds.makegp_fourier(psr, ds.powerlaw, 30, name='rednoise'),
                           ds.makegp_fourier(psr, ds.powerlaw, 14, common=['crn_log10_A', 'crn_gamma'], name='crn')])
logl = psl.logL
logp = dp.makelogprior_uniform(logl.params)
```

Then you would use `jax.jit(logl)` (and perhaps `jax.jit(jax.grad(logl)))`) and `jax.jit(logp)` in inference.
